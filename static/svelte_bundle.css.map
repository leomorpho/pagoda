{
  "version": 3,
  "sources": ["CircleSpinner.svelte", "MultiSelect.svelte", "CmdPalette.svelte", "SvelteTodoComponent.svelte"],
  "sourcesContent": ["<script>export let color = `cornflowerblue`;\nexport let duration = `1.5s`;\nexport let size = `1em`;\n</script>\n\n<div\n  style=\"--duration: {duration}\"\n  style:border-color=\"{color} transparent {color}\n  {color}\"\n  style:width={size}\n  style:height={size}\n/>\n\n<style>\n  div {\n    display: inline-block;\n    vertical-align: middle;\n    margin: 0 3pt;\n    border-width: calc(1em / 5);\n    border-style: solid;\n    border-radius: 50%;\n    animation: var(--duration) infinite rotate;\n  }\n  @keyframes rotate {\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n</style>\n", "<script>import { createEventDispatcher, tick } from 'svelte';\nimport { flip } from 'svelte/animate';\nimport CircleSpinner from './CircleSpinner.svelte';\nimport Wiggle from './Wiggle.svelte';\nimport { CrossIcon, DisabledIcon, ExpandIcon } from './icons';\nimport { get_label, get_style } from './utils';\nexport let activeIndex = null;\nexport let activeOption = null;\nexport let createOptionMsg = `Create this option...`;\nexport let allowUserOptions = false;\nexport let allowEmpty = false; // added for https://github.com/janosh/svelte-multiselect/issues/192\nexport let autocomplete = `off`;\nexport let autoScroll = true;\nexport let breakpoint = 800; // any screen with more horizontal pixels is considered desktop, below is mobile\nexport let defaultDisabledTitle = `This option is disabled`;\nexport let disabled = false;\nexport let disabledInputTitle = `This input is disabled`;\n// prettier-ignore\nexport let duplicateOptionMsg = `This option is already selected`;\nexport let duplicates = false; // whether to allow duplicate options\n// takes two options and returns true if they are equal\n// case-insensitive equality comparison after string coercion and looks only at the `label` key of object options by default\nexport let key = (opt) => `${get_label(opt)}`.toLowerCase();\nexport let filterFunc = (opt, searchText) => {\n    if (!searchText)\n        return true;\n    return `${get_label(opt)}`.toLowerCase().includes(searchText.toLowerCase());\n};\nexport let closeDropdownOnSelect = `desktop`;\nexport let form_input = null;\nexport let highlightMatches = true;\nexport let id = null;\nexport let input = null;\nexport let inputClass = ``;\nexport let inputmode = null;\nexport let invalid = false;\nexport let liActiveOptionClass = ``;\nexport let liOptionClass = ``;\nexport let liSelectedClass = ``;\nexport let loading = false;\nexport let matchingOptions = [];\nexport let maxOptions = undefined;\nexport let maxSelect = null; // null means there is no upper limit for selected.length\nexport let maxSelectMsg = (current, max) => (max > 1 ? `${current}/${max}` : ``);\nexport let maxSelectMsgClass = ``;\nexport let name = null;\nexport let noMatchingOptionsMsg = `No matching options`;\nexport let open = false;\nexport let options;\nexport let outerDiv = null;\nexport let outerDivClass = ``;\nexport let parseLabelsAsHtml = false; // should not be combined with allowUserOptions!\nexport let pattern = null;\nexport let placeholder = null;\nexport let removeAllTitle = `Remove all`;\nexport let removeBtnTitle = `Remove`;\nexport let minSelect = null; // null means there is no lower limit for selected.length\nexport let required = false;\nexport let resetFilterOnAdd = true;\nexport let searchText = ``;\nexport let selected = options\n    ?.filter((opt) => opt instanceof Object && opt?.preselected)\n    .slice(0, maxSelect ?? undefined) ?? []; // don't allow more than maxSelect preselected options\nexport let sortSelected = false;\nexport let selectedOptionsDraggable = !sortSelected;\nexport let ulOptionsClass = ``;\nexport let ulSelectedClass = ``;\nexport let value = null;\nconst selected_to_value = (selected) => {\n    value = maxSelect === 1 ? selected[0] ?? null : selected;\n};\nconst value_to_selected = (value) => {\n    if (maxSelect === 1)\n        selected = value ? [value] : [];\n    else\n        selected = value ?? [];\n};\n// if maxSelect=1, value is the single item in selected (or null if selected is empty)\n// this solves both https://github.com/janosh/svelte-multiselect/issues/86 and\n// https://github.com/janosh/svelte-multiselect/issues/136\n$: selected_to_value(selected);\n$: value_to_selected(value);\nlet wiggle = false; // controls wiggle animation when user tries to exceed maxSelect\nif (!(options?.length > 0)) {\n    if (allowUserOptions || loading || disabled || allowEmpty) {\n        options = []; // initializing as array avoids errors when component mounts\n    }\n    else {\n        // error on empty options if user is not allowed to create custom options and loading is false\n        // and component is not disabled and allowEmpty is false\n        console.error(`MultiSelect received no options`);\n    }\n}\nif (maxSelect !== null && maxSelect < 1) {\n    console.error(`MultiSelect's maxSelect must be null or positive integer, got ${maxSelect}`);\n}\nif (!Array.isArray(selected)) {\n    console.error(`MultiSelect's selected prop should always be an array, got ${selected}`);\n}\nif (maxSelect && typeof required === `number` && required > maxSelect) {\n    console.error(`MultiSelect maxSelect=${maxSelect} < required=${required}, makes it impossible for users to submit a valid form`);\n}\nif (parseLabelsAsHtml && allowUserOptions) {\n    console.warn(`Don't combine parseLabelsAsHtml and allowUserOptions. It's susceptible to XSS attacks!`);\n}\nif (sortSelected && selectedOptionsDraggable) {\n    console.warn(`MultiSelect's sortSelected and selectedOptionsDraggable should not be combined as any ` +\n        `user re-orderings of selected options will be undone by sortSelected on component re-renders.`);\n}\nif (allowUserOptions && !createOptionMsg && createOptionMsg !== null) {\n    console.error(`MultiSelect has allowUserOptions=${allowUserOptions} but createOptionMsg=${createOptionMsg} is falsy. ` +\n        `This prevents the \"Add option\" <span> from showing up, resulting in a confusing user experience.`);\n}\nif (maxOptions &&\n    (typeof maxOptions != `number` || maxOptions < 0 || maxOptions % 1 != 0)) {\n    console.error(`MultiSelect's maxOptions must be undefined or a positive integer, got ${maxOptions}`);\n}\nconst dispatch = createEventDispatcher();\nlet option_msg_is_active = false; // controls active state of <li>{createOptionMsg}</li>\nlet window_width;\n// options matching the current search text\n$: matchingOptions = options.filter((opt) => filterFunc(opt, searchText) &&\n    // remove already selected options from dropdown list unless duplicate selections are allowed\n    (!selected.map(key).includes(key(opt)) || duplicates));\n// raise if matchingOptions[activeIndex] does not yield a value\nif (activeIndex !== null && !matchingOptions[activeIndex]) {\n    throw `Run time error, activeIndex=${activeIndex} is out of bounds, matchingOptions.length=${matchingOptions.length}`;\n}\n// update activeOption when activeIndex changes\n$: activeOption = matchingOptions[activeIndex ?? -1] ?? null;\n// add an option to selected list\nfunction add(option, event) {\n    if (maxSelect && maxSelect > 1 && selected.length >= maxSelect)\n        wiggle = true;\n    if (!isNaN(Number(option)) && typeof selected.map(get_label)[0] === `number`) {\n        option = Number(option); // convert to number if possible\n    }\n    const is_duplicate = selected.map(key).includes(key(option));\n    if ((maxSelect === null || maxSelect === 1 || selected.length < maxSelect) &&\n        (duplicates || !is_duplicate)) {\n        if (!options.includes(option) && // first check if we find option in the options list\n            // this has the side-effect of not allowing to user to add the same\n            // custom option twice in append mode\n            [true, `append`].includes(allowUserOptions) &&\n            searchText.length > 0) {\n            // user entered text but no options match, so if allowUserOptions = true | 'append', we create\n            // a new option from the user-entered text\n            if (typeof options[0] === `object`) {\n                // if 1st option is an object, we create new option as object to keep type homogeneity\n                option = { label: searchText };\n            }\n            else {\n                if ([`number`, `undefined`].includes(typeof options[0]) &&\n                    !isNaN(Number(searchText))) {\n                    // create new option as number if it parses to a number and 1st option is also number or missing\n                    option = Number(searchText);\n                }\n                else {\n                    option = searchText; // else create custom option as string\n                }\n                dispatch(`create`, { option });\n            }\n            if (allowUserOptions === `append`)\n                options = [...options, option];\n        }\n        if (resetFilterOnAdd)\n            searchText = ``; // reset search string on selection\n        if ([``, undefined, null].includes(option)) {\n            console.error(`MultiSelect: encountered falsy option ${option}`);\n            return;\n        }\n        if (maxSelect === 1) {\n            // for maxSelect = 1 we always replace current option with new one\n            selected = [option];\n        }\n        else {\n            selected = [...selected, option];\n            if (sortSelected === true) {\n                selected = selected.sort((op1, op2) => {\n                    const [label1, label2] = [get_label(op1), get_label(op2)];\n                    // coerce to string if labels are numbers\n                    return `${label1}`.localeCompare(`${label2}`);\n                });\n            }\n            else if (typeof sortSelected === `function`) {\n                selected = selected.sort(sortSelected);\n            }\n        }\n        const reached_max_select = selected.length === maxSelect;\n        const dropdown_should_close = closeDropdownOnSelect === true ||\n            (closeDropdownOnSelect === `desktop` && window_width < breakpoint);\n        if (reached_max_select || dropdown_should_close) {\n            close_dropdown(event);\n        }\n        else if (!dropdown_should_close) {\n            input?.focus();\n        }\n        dispatch(`add`, { option });\n        dispatch(`change`, { option, type: `add` });\n        invalid = false; // reset error status whenever new items are selected\n        form_input?.setCustomValidity(``);\n    }\n}\n// remove an option from selected list\nfunction remove(to_remove) {\n    if (selected.length === 0)\n        return;\n    const idx = selected.findIndex((opt) => key(opt) === key(to_remove));\n    let [option] = selected.splice(idx, 1); // remove option from selected list\n    if (option === undefined && allowUserOptions) {\n        // if option with label could not be found but allowUserOptions is truthy,\n        // assume it was created by user and create corresponding option object\n        // on the fly for use as event payload\n        const other_ops_type = typeof options[0];\n        option = (other_ops_type ? { label: to_remove } : to_remove);\n    }\n    if (option === undefined) {\n        return console.error(`Multiselect can't remove selected option ${JSON.stringify(to_remove)}, not found in selected list`);\n    }\n    selected = [...selected]; // trigger Svelte rerender\n    invalid = false; // reset error status whenever items are removed\n    form_input?.setCustomValidity(``);\n    dispatch(`remove`, { option });\n    dispatch(`change`, { option, type: `remove` });\n}\nfunction open_dropdown(event) {\n    if (disabled)\n        return;\n    open = true;\n    if (!(event instanceof FocusEvent)) {\n        // avoid double-focussing input when event that opened dropdown was already input FocusEvent\n        input?.focus();\n    }\n    dispatch(`open`, { event });\n}\nfunction close_dropdown(event) {\n    open = false;\n    input?.blur();\n    activeIndex = null;\n    dispatch(`close`, { event });\n}\n// handle all keyboard events this component receives\nasync function handle_keydown(event) {\n    // on escape or tab out of input: close options dropdown and reset search text\n    if (event.key === `Escape` || event.key === `Tab`) {\n        close_dropdown(event);\n        searchText = ``;\n    }\n    // on enter key: toggle active option and reset search text\n    else if (event.key === `Enter`) {\n        event.preventDefault(); // prevent enter key from triggering form submission\n        if (activeOption) {\n            selected.includes(activeOption) ? remove(activeOption) : add(activeOption, event);\n            searchText = ``;\n        }\n        else if (allowUserOptions && searchText.length > 0) {\n            // user entered text but no options match, so if allowUserOptions is truthy, we create new option\n            add(searchText, event);\n        }\n        // no active option and no search text means the options dropdown is closed\n        // in which case enter means open it\n        else\n            open_dropdown(event);\n    }\n    // on up/down arrow keys: update active option\n    else if ([`ArrowDown`, `ArrowUp`].includes(event.key)) {\n        // if no option is active yet, but there are matching options, make first one active\n        if (activeIndex === null && matchingOptions.length > 0) {\n            activeIndex = 0;\n            return;\n        }\n        else if (allowUserOptions && !matchingOptions.length && searchText.length > 0) {\n            // if allowUserOptions is truthy and user entered text but no options match, we make\n            // <li>{addUserMsg}</li> active on keydown (or toggle it if already active)\n            option_msg_is_active = !option_msg_is_active;\n            return;\n        }\n        else if (activeIndex === null) {\n            // if no option is active and no options are matching, do nothing\n            return;\n        }\n        event.preventDefault();\n        // if none of the above special cases apply, we make next/prev option\n        // active with wrap around at both ends\n        const increment = event.key === `ArrowUp` ? -1 : 1;\n        activeIndex = (activeIndex + increment) % matchingOptions.length;\n        // in JS % behaves like remainder operator, not real modulo, so negative numbers stay negative\n        // need to do manual wrap around at 0\n        if (activeIndex < 0)\n            activeIndex = matchingOptions.length - 1;\n        if (autoScroll) {\n            await tick();\n            const li = document.querySelector(`ul.options > li.active`);\n            if (li)\n                li.scrollIntoViewIfNeeded?.();\n        }\n    }\n    // on backspace key: remove last selected option\n    else if (event.key === `Backspace` && selected.length > 0 && !searchText) {\n        remove(selected.at(-1));\n    }\n    // make first matching option active on any keypress (if none of the above special cases match)\n    else if (matchingOptions.length > 0) {\n        activeIndex = 0;\n    }\n}\nfunction remove_all() {\n    dispatch(`removeAll`, { options: selected });\n    dispatch(`change`, { options: selected, type: `removeAll` });\n    selected = [];\n    searchText = ``;\n}\n$: is_selected = (label) => selected.map(get_label).includes(label);\nconst if_enter_or_space = (handler) => (event) => {\n    if ([`Enter`, `Space`].includes(event.code)) {\n        event.preventDefault();\n        handler();\n    }\n};\nfunction on_click_outside(event) {\n    if (outerDiv && !outerDiv.contains(event.target)) {\n        close_dropdown(event);\n    }\n}\nlet drag_idx = null;\n// event handlers enable dragging to reorder selected options\nconst drop = (target_idx) => (event) => {\n    if (!event.dataTransfer)\n        return;\n    event.dataTransfer.dropEffect = `move`;\n    const start_idx = parseInt(event.dataTransfer.getData(`text/plain`));\n    const new_selected = [...selected];\n    if (start_idx < target_idx) {\n        new_selected.splice(target_idx + 1, 0, new_selected[start_idx]);\n        new_selected.splice(start_idx, 1);\n    }\n    else {\n        new_selected.splice(target_idx, 0, new_selected[start_idx]);\n        new_selected.splice(start_idx + 1, 1);\n    }\n    selected = new_selected;\n    drag_idx = null;\n};\nconst dragstart = (idx) => (event) => {\n    if (!event.dataTransfer)\n        return;\n    // only allow moving, not copying (also affects the cursor during drag)\n    event.dataTransfer.effectAllowed = `move`;\n    event.dataTransfer.dropEffect = `move`;\n    event.dataTransfer.setData(`text/plain`, `${idx}`);\n};\nlet ul_options;\n// highlight text matching user-entered search text in available options\nfunction highlight_matching_options(event) {\n    if (!highlightMatches || typeof CSS == `undefined` || !CSS.highlights)\n        return; // don't try if CSS highlight API not supported\n    // clear previous ranges from HighlightRegistry\n    CSS.highlights.clear();\n    // get input's search query\n    const query = event?.target?.value.trim().toLowerCase();\n    if (!query)\n        return;\n    const tree_walker = document.createTreeWalker(ul_options, NodeFilter.SHOW_TEXT, {\n        acceptNode: (node) => {\n            // don't highlight text in the \"no matching options\" message\n            if (node?.textContent === noMatchingOptionsMsg)\n                return NodeFilter.FILTER_REJECT;\n            return NodeFilter.FILTER_ACCEPT;\n        },\n    });\n    const text_nodes = [];\n    let current_node = tree_walker.nextNode();\n    while (current_node) {\n        text_nodes.push(current_node);\n        current_node = tree_walker.nextNode();\n    }\n    // iterate over all text nodes and find matches\n    const ranges = text_nodes.map((el) => {\n        const text = el.textContent?.toLowerCase();\n        const indices = [];\n        let start_pos = 0;\n        while (text && start_pos < text.length) {\n            const index = text.indexOf(query, start_pos);\n            if (index === -1)\n                break;\n            indices.push(index);\n            start_pos = index + query.length;\n        }\n        // create range object for each str found in the text node\n        return indices.map((index) => {\n            const range = new Range();\n            range.setStart(el, index);\n            range.setEnd(el, index + query.length);\n            return range;\n        });\n    });\n    // create Highlight object from ranges and add to registry\n    // eslint-disable-next-line no-undef\n    CSS.highlights.set(`sms-search-matches`, new Highlight(...ranges.flat()));\n}\n</script>\n\n<svelte:window\n  on:click={on_click_outside}\n  on:touchstart={on_click_outside}\n  bind:innerWidth={window_width}\n/>\n\n<div\n  bind:this={outerDiv}\n  class:disabled\n  class:single={maxSelect === 1}\n  class:open\n  class:invalid\n  class=\"multiselect {outerDivClass}\"\n  on:mouseup|stopPropagation={open_dropdown}\n  title={disabled ? disabledInputTitle : null}\n  data-id={id}\n  role=\"searchbox\"\n  tabindex=\"-1\"\n>\n  <!-- form control input invisible to the user, only purpose is to abort form submission if this component fails data validation -->\n  <!-- bind:value={selected} prevents form submission if required prop is true and no options are selected -->\n  <input\n    {name}\n    required={Boolean(required)}\n    value={selected.length >= Number(required) ? JSON.stringify(selected) : null}\n    tabindex=\"-1\"\n    aria-hidden=\"true\"\n    aria-label=\"ignore this, used only to prevent form submission if select is required but empty\"\n    class=\"form-control\"\n    bind:this={form_input}\n    on:invalid={() => {\n      invalid = true\n      let msg\n      if (maxSelect && maxSelect > 1 && Number(required) > 1) {\n        msg = `Please select between ${required} and ${maxSelect} options`\n      } else if (Number(required) > 1) {\n        msg = `Please select at least ${required} options`\n      } else {\n        msg = `Please select an option`\n      }\n      form_input?.setCustomValidity(msg)\n    }}\n  />\n  <slot name=\"expand-icon\" {open}>\n    <ExpandIcon width=\"15px\" style=\"min-width: 1em; padding: 0 1pt; cursor: pointer;\" />\n  </slot>\n  <ul class=\"selected {ulSelectedClass}\" aria-label=\"selected options\">\n    {#each selected as option, idx (duplicates ? [key(option), idx] : key(option))}\n      <li\n        class={liSelectedClass}\n        role=\"option\"\n        aria-selected=\"true\"\n        animate:flip={{ duration: 100 }}\n        draggable={selectedOptionsDraggable && !disabled && selected.length > 1}\n        on:dragstart={dragstart(idx)}\n        on:drop|preventDefault={drop(idx)}\n        on:dragenter={() => (drag_idx = idx)}\n        on:dragover|preventDefault\n        class:active={drag_idx === idx}\n        style={get_style(option, `selected`)}\n      >\n        <!-- on:dragover|preventDefault needed for the drop to succeed https://stackoverflow.com/a/31085796 -->\n        <slot name=\"selected\" {option} {idx}>\n          <slot {option} {idx}>\n            {#if parseLabelsAsHtml}\n              {@html get_label(option)}\n            {:else}\n              {get_label(option)}\n            {/if}\n          </slot>\n        </slot>\n        {#if !disabled && (minSelect === null || selected.length > minSelect)}\n          <button\n            on:mouseup|stopPropagation={() => remove(option)}\n            on:keydown={if_enter_or_space(() => remove(option))}\n            type=\"button\"\n            title=\"{removeBtnTitle} {get_label(option)}\"\n            class=\"remove\"\n          >\n            <slot name=\"remove-icon\">\n              <CrossIcon width=\"15px\" />\n            </slot>\n          </button>\n        {/if}\n      </li>\n    {/each}\n    <input\n      class={inputClass}\n      bind:this={input}\n      bind:value={searchText}\n      on:mouseup|self|stopPropagation={open_dropdown}\n      on:keydown|stopPropagation={handle_keydown}\n      on:focus\n      on:focus={open_dropdown}\n      on:input={highlight_matching_options}\n      {id}\n      {disabled}\n      {autocomplete}\n      {inputmode}\n      {pattern}\n      placeholder={selected.length == 0 ? placeholder : null}\n      aria-invalid={invalid ? `true` : null}\n      ondrop=\"return false\"\n      on:blur\n      on:change\n      on:click\n      on:keydown\n      on:keyup\n      on:mousedown\n      on:mouseenter\n      on:mouseleave\n      on:touchcancel\n      on:touchend\n      on:touchmove\n      on:touchstart\n    />\n    <!-- the above on:* lines forward potentially useful DOM events -->\n    <slot\n      name=\"after-input\"\n      {selected}\n      {disabled}\n      {invalid}\n      {id}\n      {placeholder}\n      {open}\n      {required}\n    />\n  </ul>\n  {#if loading}\n    <slot name=\"spinner\">\n      <CircleSpinner />\n    </slot>\n  {/if}\n  {#if disabled}\n    <slot name=\"disabled-icon\">\n      <DisabledIcon width=\"14pt\" style=\"margin: 0 2pt;\" data-name=\"disabled-icon\" />\n    </slot>\n  {:else if selected.length > 0}\n    {#if maxSelect && (maxSelect > 1 || maxSelectMsg)}\n      <Wiggle bind:wiggle angle={20}>\n        <span class=\"max-select-msg {maxSelectMsgClass}\">\n          {maxSelectMsg?.(selected.length, maxSelect)}\n        </span>\n      </Wiggle>\n    {/if}\n    {#if maxSelect !== 1 && selected.length > 1}\n      <button\n        type=\"button\"\n        class=\"remove remove-all\"\n        title={removeAllTitle}\n        on:mouseup|stopPropagation={remove_all}\n        on:keydown={if_enter_or_space(remove_all)}\n      >\n        <slot name=\"remove-icon\">\n          <CrossIcon width=\"15px\" />\n        </slot>\n      </button>\n    {/if}\n  {/if}\n\n  <!-- only render options dropdown if options or searchText is not empty (needed to avoid briefly flashing empty dropdown) -->\n  {#if (searchText && noMatchingOptionsMsg) || options?.length > 0}\n    <ul\n      class:hidden={!open}\n      class=\"options {ulOptionsClass}\"\n      role=\"listbox\"\n      aria-multiselectable={maxSelect === null || maxSelect > 1}\n      aria-expanded={open}\n      aria-disabled={disabled ? `true` : null}\n      bind:this={ul_options}\n    >\n      {#each matchingOptions.slice(0, Math.max(0, maxOptions ?? 0) || Infinity) as option, idx}\n        {@const {\n          label,\n          disabled = null,\n          title = null,\n          selectedTitle = null,\n          disabledTitle = defaultDisabledTitle,\n        } = option instanceof Object ? option : { label: option }}\n        {@const active = activeIndex === idx}\n        <li\n          on:mousedown|stopPropagation\n          on:mouseup|stopPropagation={(event) => {\n            if (!disabled) add(option, event)\n          }}\n          title={disabled\n            ? disabledTitle\n            : (is_selected(label) && selectedTitle) || title}\n          class:selected={is_selected(label)}\n          class:active\n          class:disabled\n          class=\"{liOptionClass} {active ? liActiveOptionClass : ``}\"\n          on:mouseover={() => {\n            if (!disabled) activeIndex = idx\n          }}\n          on:focus={() => {\n            if (!disabled) activeIndex = idx\n          }}\n          on:mouseout={() => (activeIndex = null)}\n          on:blur={() => (activeIndex = null)}\n          role=\"option\"\n          aria-selected=\"false\"\n          style={get_style(option, `option`)}\n        >\n          <slot name=\"option\" {option} {idx}>\n            <slot {option} {idx}>\n              {#if parseLabelsAsHtml}\n                {@html get_label(option)}\n              {:else}\n                {get_label(option)}\n              {/if}\n            </slot>\n          </slot>\n        </li>\n      {/each}\n      {#if searchText}\n        {@const text_input_is_duplicate = selected.map(get_label).includes(searchText)}\n        {@const is_dupe = !duplicates && text_input_is_duplicate && `dupe`}\n        {@const can_create = Boolean(allowUserOptions && createOptionMsg) && `create`}\n        {@const no_match =\n          Boolean(matchingOptions?.length == 0 && noMatchingOptionsMsg) && `no-match`}\n        {@const msgType = is_dupe || can_create || no_match}\n        {#if msgType}\n          {@const msg = {\n            dupe: duplicateOptionMsg,\n            create: createOptionMsg,\n            'no-match': noMatchingOptionsMsg,\n          }[msgType]}\n          <li\n            on:mousedown|stopPropagation\n            on:mouseup|stopPropagation={(event) => {\n              if (allowUserOptions) add(searchText, event)\n            }}\n            title={createOptionMsg}\n            class:active={option_msg_is_active}\n            on:mouseover={() => (option_msg_is_active = true)}\n            on:focus={() => (option_msg_is_active = true)}\n            on:mouseout={() => (option_msg_is_active = false)}\n            on:blur={() => (option_msg_is_active = false)}\n            role=\"option\"\n            aria-selected=\"false\"\n            class=\"user-msg\"\n            style:cursor={{\n              dupe: `not-allowed`,\n              create: `pointer`,\n              'no-match': `default`,\n            }[msgType]}\n          >\n            <slot name=\"user-msg\" {searchText} {msgType} {msg}>\n              {msg}\n            </slot>\n          </li>\n        {/if}\n      {/if}\n    </ul>\n  {/if}\n</div>\n\n<style>\n  :where(div.multiselect) {\n    position: relative;\n    align-items: center;\n    display: flex;\n    cursor: text;\n    box-sizing: border-box;\n    border: var(--sms-border, 1pt solid lightgray);\n    border-radius: var(--sms-border-radius, 3pt);\n    background: var(--sms-bg);\n    width: var(--sms-width);\n    max-width: var(--sms-max-width);\n    padding: var(--sms-padding, 0 3pt);\n    color: var(--sms-text-color);\n    font-size: var(--sms-font-size, inherit);\n    min-height: var(--sms-min-height, 22pt);\n    margin: var(--sms-margin);\n  }\n  :where(div.multiselect.open) {\n    /* increase z-index when open to ensure the dropdown of one <MultiSelect />\n    displays above that of another slightly below it on the page */\n    z-index: var(--sms-open-z-index, 4);\n  }\n  :where(div.multiselect:focus-within) {\n    border: var(--sms-focus-border, 1pt solid var(--sms-active-color, cornflowerblue));\n  }\n  :where(div.multiselect.disabled) {\n    background: var(--sms-disabled-bg, lightgray);\n    cursor: not-allowed;\n  }\n\n  :where(div.multiselect > ul.selected) {\n    display: flex;\n    flex: 1;\n    padding: 0;\n    margin: 0;\n    flex-wrap: wrap;\n  }\n  :where(div.multiselect > ul.selected > li) {\n    align-items: center;\n    border-radius: 3pt;\n    display: flex;\n    margin: 2pt;\n    line-height: normal;\n    transition: 0.3s;\n    white-space: nowrap;\n    background: var(--sms-selected-bg, rgba(0, 0, 0, 0.15));\n    padding: var(--sms-selected-li-padding, 1pt 5pt);\n    color: var(--sms-selected-text-color, var(--sms-text-color));\n  }\n  :where(div.multiselect > ul.selected > li[draggable='true']) {\n    cursor: grab;\n  }\n  :where(div.multiselect > ul.selected > li.active) {\n    background: var(--sms-li-active-bg, var(--sms-active-color, rgba(0, 0, 0, 0.15)));\n  }\n  :where(div.multiselect button) {\n    border-radius: 50%;\n    display: flex;\n    transition: 0.2s;\n    color: inherit;\n    background: transparent;\n    border: none;\n    cursor: pointer;\n    outline: none;\n    padding: 0;\n    margin: 0 0 0 3pt; /* CSS reset */\n  }\n  :where(div.multiselect button.remove-all) {\n    margin: 0 3pt;\n  }\n  :where(ul.selected > li button:hover, button.remove-all:hover, button:focus) {\n    color: var(--sms-remove-btn-hover-color, lightskyblue);\n    background: var(--sms-remove-btn-hover-bg, rgba(0, 0, 0, 0.2));\n  }\n\n  :where(div.multiselect input) {\n    margin: auto 0; /* CSS reset */\n    padding: 0; /* CSS reset */\n  }\n  :where(div.multiselect > ul.selected > input) {\n    border: none;\n    outline: none;\n    background: none;\n    flex: 1; /* this + next line fix issue #12 https://git.io/JiDe3 */\n    min-width: 2em;\n    /* ensure input uses text color and not --sms-selected-text-color */\n    color: var(--sms-text-color);\n    font-size: inherit;\n    cursor: inherit; /* needed for disabled state */\n    border-radius: 0; /* reset ul.selected > li */\n  }\n  /* don't wrap ::placeholder rules in :where() as it seems to be overpowered by browser defaults i.t.o. specificity */\n  div.multiselect > ul.selected > input::placeholder {\n    padding-left: 5pt;\n    color: var(--sms-placeholder-color);\n    opacity: var(--sms-placeholder-opacity);\n  }\n  :where(div.multiselect > input.form-control) {\n    width: 2em;\n    position: absolute;\n    background: transparent;\n    border: none;\n    outline: none;\n    z-index: -1;\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  :where(div.multiselect > ul.options) {\n    list-style: none;\n    top: 100%;\n    left: 0;\n    width: 100%;\n    position: absolute;\n    overflow: auto;\n    transition: all 0.2s;\n    box-sizing: border-box;\n    background: var(--sms-options-bg, white);\n    max-height: var(--sms-options-max-height, 50vh);\n    overscroll-behavior: var(--sms-options-overscroll, none);\n    box-shadow: var(--sms-options-shadow, 0 0 14pt -8pt black);\n    border: var(--sms-options-border);\n    border-width: var(--sms-options-border-width);\n    border-radius: var(--sms-options-border-radius, 1ex);\n    padding: var(--sms-options-padding);\n    margin: var(--sms-options-margin, inherit);\n  }\n  :where(div.multiselect > ul.options.hidden) {\n    visibility: hidden;\n    opacity: 0;\n    transform: translateY(50px);\n  }\n  :where(div.multiselect > ul.options > li) {\n    padding: 3pt 2ex;\n    cursor: pointer;\n    scroll-margin: var(--sms-options-scroll-margin, 100px);\n  }\n  :where(div.multiselect > ul.options .user-msg) {\n    /* block needed so vertical padding applies to span */\n    display: block;\n    padding: 3pt 2ex;\n  }\n  :where(div.multiselect > ul.options > li.selected) {\n    background: var(--sms-li-selected-bg);\n    color: var(--sms-li-selected-color);\n  }\n  :where(div.multiselect > ul.options > li.active) {\n    background: var(--sms-li-active-bg, var(--sms-active-color, rgba(0, 0, 0, 0.15)));\n  }\n  :where(div.multiselect > ul.options > li.disabled) {\n    cursor: not-allowed;\n    background: var(--sms-li-disabled-bg, #f5f5f6);\n    color: var(--sms-li-disabled-text, #b8b8b8);\n  }\n\n  :where(span.max-select-msg) {\n    padding: 0 3pt;\n  }\n  ::highlight(sms-search-matches) {\n    color: mediumaquamarine;\n  }\n</style>\n", "<script>import { tick } from 'svelte';\nimport { fade } from 'svelte/transition';\nimport Select from './MultiSelect.svelte';\nexport let actions;\nexport let triggers = [`k`];\nexport let close_keys = [`Escape`];\nexport let fade_duration = 200; // in ms\nexport let style = ``; // for dialog\n// for span in option slot, has no effect when passing a slot\nexport let span_style = ``;\nexport let open = false;\nexport let dialog = null;\nexport let input = null;\nexport let placeholder = `Filter actions...`;\nasync function toggle(event) {\n    if (triggers.includes(event.key) && event.metaKey && !open) {\n        // open on cmd+trigger\n        open = true;\n        await tick(); // wait for dialog to open and input to be mounted\n        input?.focus();\n    }\n    else if (close_keys.includes(event.key) && open) {\n        open = false;\n    }\n}\nfunction close_if_outside(event) {\n    if (open && !dialog?.contains(event.target)) {\n        open = false;\n    }\n}\nfunction run_and_close(event) {\n    event.detail.option.action();\n    open = false;\n}\n</script>\n\n<svelte:window on:keydown={toggle} on:click={close_if_outside} />\n\n{#if open}\n  <dialog open bind:this={dialog} transition:fade={{ duration: fade_duration }} {style}>\n    <Select\n      options={actions}\n      bind:input\n      {placeholder}\n      on:add={run_and_close}\n      on:keydown={toggle}\n      {...$$restProps}\n      let:option\n    >\n      <!-- wait for https://github.com/sveltejs/svelte/pull/8304 -->\n      <slot>\n        <span style={span_style}>{option.label}</span>\n      </slot>\n    </Select>\n  </dialog>\n{/if}\n\n<style>\n  :where(dialog) {\n    position: fixed;\n    top: 30%;\n    border: none;\n    padding: 0;\n    background-color: transparent;\n    display: flex;\n    color: white;\n    z-index: 10;\n    font-size: 2.4ex;\n  }\n  dialog :global(div.multiselect) {\n    --sms-bg: var(--sms-options-bg);\n    --sms-width: min(20em, 90vw);\n    --sms-max-width: none;\n    --sms-placeholder-color: lightgray;\n    --sms-options-margin: 1px 0;\n    --sms-options-border-radius: 0 0 1ex 1ex;\n  }\n</style>\n", "<script>\n  let todos = [];\n  let newTodo = \"\";\n\n  function addTodo() {\n    if (newTodo.trim()) {\n      todos = [...todos, { id: Date.now(), text: newTodo, done: false }];\n      newTodo = \"\";\n    }\n  }\n\n  function removeTodo(id) {\n    todos = todos.filter(todo => todo.id !== id);\n  }\n\n  function toggleDone(id) {\n    todos = todos.map(todo =>\n      todo.id === id ? { ...todo, done: !todo.done } : todo\n    );\n  }\n</script>\n\n<div class=\"max-w-md mx-auto my-10 bg-white dark:bg-gray-900 text-black dark:text-white shadow-lg rounded-lg overflow-hidden\">\n  <div class=\"px-6 py-4\">\n    <div class=\"font-bold text-xl mb-2\">Todos</div>\n    <div class=\"flex justify-between mb-4\">\n      <input\n        class=\"shadow appearance-none rounded w-full py-2 px-3 mr-4 text-black dark:text-white bg-gray-100 dark:bg-gray-700\"\n        bind:value={newTodo}\n        on:keydown={event => event.key === 'Enter' && addTodo()}\n        placeholder=\"Add new todo\"\n      />\n      <button\n        class=\"flex-no-shrink p-2 rounded-lg text-white bg-teal-500 hover:bg-teal-400 transition-colors duration-200 ease-in-out\"\n        on:click={addTodo}\n      >\n        Add\n      </button>\n    </div>\n\n    {#each todos as todo}\n      <div class=\"flex items-center justify-between mb-4 bg-gray-100 dark:bg-gray-700 text-black dark:text-white rounded p-2\">\n        <div class=\"flex items-center\">\n          <input type=\"checkbox\" class=\"mr-2 leading-tight\" bind:checked={todo.done} on:click={() => toggleDone(todo.id)} />\n          <p class=\"{todo.done ? 'text-gray-500 line-through' : 'text-gray-900'}\">\n            {todo.text}\n          </p>\n        </div>\n        <button\n          class=\"flex-no-shrink p-2 rounded-lg text-white bg-red-500 hover:bg-red-400 transition-colors duration-200 ease-in-out\"\n          on:click={() => removeTodo(todo.id)}\n        >\n          Remove\n        </button>\n      </div>\n    {/each}\n  </div>\n</div>\n\n<style>\n  .line-through {\n    text-decoration: line-through;\n  }\n</style>\n"],
  "mappings": "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",
  "names": []
}
